Hello, I'm Andrew Stitcher, I work for Red Hat which as you know is a
large open source company and the open source world provides at least
some of the perspective for this talk: "When only C will do"

Looking at a couple of the other talks at this years ACCU conference I
think I might be taking a rather unpopular
direction. After all you might have just come from a talk telling you
that C is going the way of the Dodo - or perhaps that isn't exactly
what Dirk was saying - I couldn't get
to that talk as I was busy here in this room trying to keep people from
their post prandial nap! I hope I succeeded for at least some of them.

And tomorrow none other than Bob Martin is giving what sounds like a
eulogy for C - "I come to bury C, not to praise it" anyone?

When I put the proposal for this session together, oh, way back in
September I think, I was fairly convinced by the arguments I'm going
to bring you in the next few minutes. However as I thought more and
actually starting preparing this talk my views have changed a bit. So
it's fair to treat this as a bit of a "devils advocate" position - see
if you can tell when I don't actually believe what I'm telling you!

However it worth pointing out now that in this talk I'm coming from a
very practical standpoint. I'm not going to be telling of anything the
theorectically C can do that no other language can do (though there
may be some things like that). Pretty much everything I'm talking
about here is about actually programming in the real world or at least
in the open source world which is some sort of approximation to the
real world!

[2 mins to here]?

I started thinking about C and its uses because of the project I work
on for money. This is the Qpid project which is an implementation of
the AMQP protocol. And this is a protocol used to provide messaging
middleware (ooh I hate that jargon) capabilities. In practice what
this means is that AMQP systems have a central message broker which clients
talk to to transfer their messages. The language the broker is written
in is unimportant at the moment because it's not visible at this
architectural level, all communication between the clients is via the
broker using the standardised AMQP protocol.

[A little picture of broker and client might actually help here]

Now here is an interesting thing, people want to be able to use
messaging between components of their systems irrespective of what
language they write their systems in, so that picture turns into
something more like this

[Picture of broker and clients again but each client is in a different
language]

At present the Qpid project is supporting APIs for quite a few
languages and environments: C++, Java JMS, Python, ruby, Perl, and
also the .Net environment, we also support Linux and Windows
platforms, and Solaris and FreeBSD aren't far away.

For good historical reasons the project has 3 different separate
implementations of the AMQP protocol - in Java, in C++ and in
Python - notice that none of these are C!. Most of the other language
APIs actually layer on top of the C++ API
using a great tool called SWIG which knows how to automatically create
code to tie an API into the foreign function interface for that
language implementation. The .Net implementation is actually built on
top of hand built code which does similar. So we are currently
maintaining 3 different implementations of the same protocol, at this
point you might be getting a glimmer of where I'm going!

Now this is quite as bad as you might think, because this is a defined
protocol with an actual written standard so it's not as bad as having
say to reverse engineer the protocol from one set of code to implement
it in the other.

Ok, I lied before, when I said AMQP was a standard, well sort of, the
problem is that it's not just one standard! Over the years it has
passed through a number of revisions 0-8, 0-9, 0-9.1, 0-10 and now it
has a proposed standard 1.0 revision which is currently making it's
way through the OASIS standardisation process.

[Picture of the different protocols?]

Qpid actually supports the 0-10 standard in all the languages and the
Java code also supports some of the earlier versions too (0-9 I think)

So presently our big task is to implement the 1.0 protocol
version. And obviously we want to do this with the minimum effort now
and the minimum effort going forwards in maintenance.

So this has led us into thinking about writing code that would be usable
in all of these environments and languages.

Another goal of the project is to be broadly portable to as many
platforms as possible, from embedded (though probably not the tiniest PLCs)
through mobile handsets to the more standard desktop and server
environments. 

So now you can see where I was originally coming from.

It seems that C is going to be something like a practical solution to
many (possibly all) these problems.

[7.5mins to here]

So how does it help us?

[Essential motivating point - C is a very good common language to program in as nearly every other
language/system can interface directly to it]

This by itself doesn't necessarily mean that you have to write your code in C itself just that it needs to have
a good C interface. Now C++ has extern "C" which allows pretty good interoperation with C on this
level.

However then portability is felt. While it's perhaps not 100% true to say that every machine has a
C compiler. It 's probably very close to the truth, in any case every practical machine that we care
about does have a C compiler, from the smallest. Hold on a sec though, many or most of those compilers are
actually gcc the gnu compiler collection and C++ is actually supported by gcc - actually one of the
best C++ compilers out there. However C++ has a much more substantial runtime support library than C
and that is not actually available everywhere. Still I find it notable that the arduino compiler
environment (which is based on gcc) actually does support C++ although possibly not with the full
language (exception and runtime type info are almost certainly not present in the supplied runtime).
The arduino as you'll know is a hobbyist microcontroller with only a few k of program memory (16/32k)
and even less RAM (1/2k).

This is C as portable assembler: For pretty much every platform you care about the C ABI is standardised.
therefore if you write a library on C anyone can use it. This is emphatically not the case for C++.
Until quite recently C++ had hardly a standard ABI on any platform - Solaris provides an
example where there still are commonly 2 C++ ABIs (GCCs and SunPros - or whatever Oracle call it now)
that might be in use, meaning that producing a
C++ library for use by an unknown developer can be an exercise in high frustration. As even if they
accidentally link together nothing good will happen afterwards. This can even be an issue if the
exported API/ABI is actually C because the runtimes are incompatible. Essentially it means that you
end up producing 2 library variants.

[Next points - Social community based points - essentially that C++ is not a great language for
OS community projects.
* Open source systems software is almost entirely written in C (The new linker gold is about the only
exception I could find), and there is not so much
experience in this world with maintaining C++ code, there is actually a level of antagonism to the
language - in the real world this is an issue.
* C++ is a big complex language and in a loose community it is hard to coalesce on a subset, as
there is always someone who wants to try that exciting feature they've just heard about. This means
that the code can grow in mutually incomprehensible silos. As only a developer who has worked on a section
of code can maintain that code easily. This quickly becomes a barrier to development.
* More importantly it is a strong barrier to new people being able to quickly and casually hack
on the codebase and this is an important problem for an open source project. well they can but they
are for too likely to make mistakes
* And finally this leads to tool support for C++ has been too weak historically (it getting better
now that clang supports nearly all of the modern language, and is designed so that you can use its
parser in your own tools). This has meant that it was practically impossible for us to automate
any sort of language checking.

Of course

C as low level language, again portable assembler:
* C hides very little from you and doesn't as much as generate a hidden indirect call. So this
can be pretty important if you want to have full control and understanding over what the machine
is doing.

It also means that you're not locked into doing classes for example in exactly the way that C++
does it. It'll be more verbose, and you might end up using macros to help you (ugh!) but you
could implement say prototype based OO and do it efficiently.

[Pitfalls - actually not C pitfalls per se perhaps,
need to understand the threading environment of the language your
binding into. Or at least need to make sure that the API you expose
doesn't require grabbing control or creating a thread.
